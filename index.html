const SUPABASE_URL = "https://tekuxjnnwtqmygibvwux.supabase.co";
const SUPABASE_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InRla3V4am5ud3RxbXlnaWJ2d3V4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzNDUzNjAsImV4cCI6MjA3MDkyMTM2MH0.RGmuF44husXoJP8y4U1Gx7HqQJ6MsYZVl6_vHtG-KJY";
const BOT_TOKEN = "8341196303:AAFbT_px8I12_q2b7AI_c00N3nHzFwLb4pg";
const ADMIN_ID = 8392100400;
const CHANNEL_IDS = ["-1002841497873", "-1002795304513", "-1002834136499", "-1002615160035"];
const GROUP_IDS = ["-1002737769800", "-1002735235059"];
const ADMIN_API_KEY = "MySuperSecureKey123!"; 

// å¤„ç†OPTIONSè¯·æ±‚
function handleOptions() {
  return new Response(null, {
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'GET, POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Admin-Key',
      'Access-Control-Max-Age': '86400'
    }
  });
}

// è®¾ç½®CORSå¤´
function setCorsHeaders(response) {
  const headers = new Headers(response.headers);
  headers.set('Access-Control-Allow-Origin', '*');
  return new Response(response.body, {
    status: response.status,
    statusText: response.statusText,
    headers: headers
  });
}

async function handleRequest(request) {
  try {
    const url = new URL(request.url);
    
    if (request.method === "OPTIONS") {
      return handleOptions();
    }

    // æµ‹è¯•æ•°æ®åº“è¿žæŽ¥
    if (request.method === "GET" && url.pathname === "/test-db") {
      const response = await testDatabaseConnection();
      return setCorsHeaders(response);
    }

    // å®šæ—¶ä»»åŠ¡
    if (request.method === "GET" && url.pathname === "/send-random-teacher") {
      const response = await handleSendRandomTeacher();
      return setCorsHeaders(response);
    }

    // åŽå°ç®¡ç†API
    if (request.method === "POST" && url.pathname === "/admin-api") {
      const response = await handleAdminAPI(request);
      return setCorsHeaders(response);
    }

    // Telegramæ›´æ–°å¤„ç†
    if (request.method === "POST") {
      const update = await request.json();
      return handleUpdate(update);
    }

    return new Response("Telegram Bot is running");
  } catch (e) {
    console.error("å…¨å±€é”™è¯¯:", e);
    return setCorsHeaders(new Response(JSON.stringify({ 
      error: "æœåŠ¡å™¨é”™è¯¯", 
      details: e.message 
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    }));
  }
}

// æµ‹è¯•æ•°æ®åº“è¿žæŽ¥
async function testDatabaseConnection() {
  try {
    const users = await supabaseFetchAll('users');
    return new Response(JSON.stringify({
      status: "success",
      users_count: users.length
    }), {
      headers: { "Content-Type": "application/json" }
    });
  } catch (error) {
    return new Response(JSON.stringify({
      status: "error",
      message: error.message
    }), {
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
}

// ç®¡ç†å‘˜APIå¤„ç†
async function handleAdminAPI(request) {
  const apiKey = request.headers.get('Admin-Key');

  console.log("æ”¶åˆ°çš„APIå¯†é’¥:", apiKey ? "å­˜åœ¨" : "ä¸å­˜åœ¨");
  console.log("é¢„æœŸçš„APIå¯†é’¥:", ADMIN_API_KEY);
  
  if (!apiKey || apiKey !== ADMIN_API_KEY) {
    console.warn(`å¯†é’¥éªŒè¯å¤±è´¥: æ”¶åˆ°${apiKey || 'ç©ºå€¼'}`);
    return new Response(JSON.stringify({ 
      error: "Unauthorized",
      message: "ç®¡ç†å‘˜å¯†é’¥ä¸æ­£ç¡®"
    }), {
      status: 401,
      headers: { "Content-Type": "application/json" }
    });
  }

  try {
    const { action, table, data, filter } = await request.json();

    const validTables = ['users', 'teachers', 'keywords', 'banned_keywords'];
    if (!validTables.includes(table)) {
      throw new Error(`éžæ³•è¡¨å: ${table}`);
    }

    switch (action) {
      case "get":
        const records = await supabaseFetchAll(table, filter);
        return new Response(JSON.stringify(records), {
          headers: { "Content-Type": "application/json" }
        });
      case "update":
        await supabaseUpsert(table, data, 'id');
        return new Response(JSON.stringify({ status: "success" }), {
          headers: { "Content-Type": "application/json" }
        });
      case "insert":
        await supabaseInsert(table, data);
        return new Response(JSON.stringify({ status: "success" }), {
          headers: { "Content-Type": "application/json" }
        });
      case "delete":
        await supabaseDelete(table, data.id);
        return new Response(JSON.stringify({ status: "success" }), {
          headers: { "Content-Type": "application/json" }
        });
      default:
        return new Response(JSON.stringify({ error: "Invalid action" }), { status: 400 });
    }
  } catch (error) {
    console.error("ç®¡ç†APIé”™è¯¯:", error);
    return new Response(JSON.stringify({ 
      error: "æ•°æ®åº“æ“ä½œå¤±è´¥",
      details: error.message 
    }), { 
      status: 500,
      headers: { "Content-Type": "application/json" }
    });
  }
}

// Telegramæ¶ˆæ¯å¤„ç†
async function handleUpdate(update) {
  if (!update.message) return new Response("OK");
  
  const { message } = update;
  const chatId = message.chat.id;
  const userId = message.from.id;
  const text = message.text || "";
  
  console.log(`æ”¶åˆ°æ¶ˆæ¯: ${text}`);
  
  const keywordResponse = await handleKeywordReply(text, chatId);
  if (keywordResponse) return keywordResponse;
  
  const banResponse = await handleBannedKeyword(text, message);
  if (banResponse) return banResponse;
  
  if (text === "ç­¾åˆ°") {
    return handleSign(chatId, userId, message.from);
  }
  
  if (text === "ç§¯åˆ†") {
    return handlePoints(chatId, userId);
  }
  
  if (text === "ç§¯åˆ†æŽ’è¡Œ") {
    return handlePointsRanking(chatId);
  }
  
  if (text === "ä¸Šä¼ è€å¸ˆ") {
    const template = "ðŸ“¸ è¯·å‘é€ç…§ç‰‡å’Œè€å¸ˆä¿¡æ¯ï¼Œæ ¼å¼å¦‚ä¸‹ï¼š\n\nèŠ±å,å¹´é¾„,åœ°åŒº,Telegramè´¦å·,é¢‘é“é“¾æŽ¥,æœåŠ¡ç±»åž‹,ä¿®è½¦è´¹,è‡ªæˆ‘ä»‹ç»\n\nç¤ºä¾‹ï¼š\nç”œç”œ,18,æ˜Œå¹³å¤©é€šè‹‘,@lisifu,https://t.me/lisifu_channel,æ¯’é¾™ 69 æ·±å–‰ç­‰,600p 1200pp,æ¸©æŸ”ä½“è´´ ä¸å‚¬äºº ä¸æœºè½¦";
    return sendMessage(chatId, template);
  }
  
  if (message.photo) {
    return handlePhotoMessage(message, chatId);
  }
  
  return new Response("OK");
}

// ç­¾åˆ°åŠŸèƒ½
async function handleSign(chatId, userId, userInfo) {
  try {
    const today = new Date().toISOString().split('T')[0];
    const user = await supabaseFetch('users', `user_id=eq.${userId}`);
    
    if (user && user.last_sign_date === today) {
      return sendMessage(chatId, "âŒ æ‚¨ä»Šå¤©å·²ç»ç­¾åˆ°è¿‡äº†ï¼", message.message_id);
    }
    
    const points = user ? (user.points || 0) + 10 : 10;
    
    const userData = {
      user_id: userId,
      points,
      last_sign_date: today,
      username: userInfo.username || "",
      first_name: userInfo.first_name || "",
      last_name: userInfo.last_name || "",
      display_name: userInfo.display_name || "" 
    };
    
    await supabaseUpsert('users', userData, 'user_id');
    
    const todaySigns = await supabaseFetchAll('users', `last_sign_date=eq.${today}`);
    const signRank = todaySigns.length;
    
    return sendMessage(chatId, `ðŸŽ‰ ç­¾åˆ°æˆåŠŸï¼+10ç§¯åˆ†\nðŸ’° å½“å‰ç§¯åˆ†: ${points}\nðŸ† æ‚¨æ˜¯ä»Šæ—¥ç¬¬${signRank}ä½ç­¾åˆ°æˆå‘˜`, message.message_id);
  } catch (error) {
    console.error("ç­¾åˆ°é”™è¯¯:", error);
    return sendMessage(chatId, "âŒ ç­¾åˆ°å¤±è´¥ï¼Œè¯·ç¨åŽå†è¯•", message.message_id);
  }
}

// ç§¯åˆ†æŸ¥è¯¢
async function handlePoints(chatId, userId) {
  try {
    const user = await supabaseFetch('users', `user_id=eq.${userId}`);
    const points = user ? (user.points || 0) : 0;
    
    const allUsers = await supabaseFetchAll('users');
    allUsers.sort((a, b) => (b.points || 0) - (a.points || 0));
    const userRank = allUsers.findIndex(u => u.user_id === userId) + 1;
    
    const displayName = user.display_name || `${user.first_name} ${user.last_name}` || user.username || 'æœªçŸ¥ç”¨æˆ·';
    return sendMessage(chatId, `ðŸ’° ${displayName}çš„å½“å‰ç§¯åˆ†: ${points}\nðŸ† åœ¨æœ¬ç¾¤æŽ’å: ${userRank}/${allUsers.length}`, message.message_id);
  } catch (error) {
    console.error("ç§¯åˆ†æŸ¥è¯¢é”™è¯¯:", error);
    return sendMessage(chatId, "âŒ æŸ¥è¯¢ç§¯åˆ†å¤±è´¥", message.message_id);
  }
}

// ç§¯åˆ†æŽ’è¡Œ
async function handlePointsRanking(chatId) {
  try {
    const allUsers = await supabaseFetchAll('users');
    allUsers.sort((a, b) => (b.points || 0) - (a.points || 0));
    
    let rankMsg = "ðŸ† ç§¯åˆ†æŽ’è¡Œæ¦œ TOP 10 ðŸ†\n\n";
    const topUsers = allUsers.slice(0, 10);
    
    topUsers.forEach((user, index) => {
      const displayName = user.display_name || `${user.first_name} ${user.last_name}` || user.username || 'æœªçŸ¥ç”¨æˆ·';
      rankMsg += `${index + 1}. ${displayName}: ${user.points || 0}åˆ†\n`;
    });
    
    return sendMessage(chatId, rankMsg);
  } catch (error) {
    console.error("ç§¯åˆ†æŽ’åé”™è¯¯:", error);
    return sendMessage(chatId, "âŒ èŽ·å–ç§¯åˆ†æŽ’åå¤±è´¥", message.message_id);
  }
}

// å…³é”®è¯å›žå¤åŠŸèƒ½
async function handleKeywordReply(text, chatId) {
  const keywords = await getKeywordReplies();
  const lowerText = text.toLowerCase();
  
  for (const [keyword, reply] of Object.entries(keywords)) {
    if (lowerText.includes(keyword.toLowerCase())) {
      await sendMessage(chatId, reply, message.message_id);
      return new Response("OK");
    }
  }
  return null;
}

// èŽ·å–å…³é”®è¯å›žå¤
async function getKeywordReplies() {
  try {
    const keywords = await supabaseFetchAll('keywords', 'is_active=eq.true');
    const keywordMap = {};
    keywords.forEach(k => {
      keywordMap[k.keyword] = k.response;
    });
    return keywordMap;
  } catch (error) {
    console.error("èŽ·å–å…³é”®è¯å¤±è´¥:", error);
    return {
      "ä½ å¥½": "æ‚¨å¥½ï¼æœ‰ä»€ä¹ˆå¯ä»¥å¸®æ‚¨ï¼Ÿ",
      "å¸®åŠ©": "è¿™é‡Œæ˜¯å¸®åŠ©ä¿¡æ¯ï¼š\n- ç­¾åˆ°ï¼šå‘é€ã€Œç­¾åˆ°ã€\n- ç§¯åˆ†æŸ¥è¯¢ï¼šå‘é€ã€Œç§¯åˆ†ã€",
      "ä»·æ ¼": "æœåŠ¡ä»·æ ¼è¡¨ï¼š\n- åŸºç¡€è¯¾ç¨‹ï¼š100ç§¯åˆ†\n- é«˜çº§è¯¾ç¨‹ï¼š300ç§¯åˆ†"
    };
  }
}

// ç¦è¨€ç³»ç»Ÿ
async function handleBannedKeyword(text, message) {
  const bannedKeywords = await getBannedKeywords();
  const lowerText = text.toLowerCase();
  
  for (const keyword of bannedKeywords) {
    if (lowerText.includes(keyword.toLowerCase())) {
      if (message.chat.type === 'group' || message.chat.type === 'supergroup') {
        const chatId = message.chat.id;
        const userId = message.from.id;
        
        await deleteMessage(chatId, message.message_id);
        await restrictChatMember(chatId, userId, 3600);
        
        await sendMessage(chatId, `ç”¨æˆ· @${message.from.username || message.from.first_name} å› å‘é€è¿ç¦è¯å·²è¢«ç¦è¨€1å°æ—¶ã€‚`, message.message_id);
      }
      return new Response("OK");
    }
  }
  return null;
}

// èŽ·å–ç¦è¨€è¯
async function getBannedKeywords() {
  try {
    const banned = await supabaseFetchAll('banned_keywords');
    return banned.map(b => b.keyword);
  } catch (error) {
    console.error("èŽ·å–ç¦è¨€è¯å¤±è´¥:", error);
    return ["èµŒåš", "æ¯’å“", "è¯ˆéª—", "å¹¿å‘Š"];
  }
}

// è€å¸ˆä¸Šä¼ åŠŸèƒ½
async function handlePhotoMessage(message, chatId) {
  try {
    const photo = message.photo[message.photo.length - 1];
    const photoUrl = await getFileUrl(photo.file_id);
    const caption = message.caption || "";
    
    if (!caption) {
      return sendMessage(chatId, "âŒ è¯·æ·»åŠ è¯´æ˜Žæ–‡å­—ï¼Œæ ¼å¼ï¼šèŠ±å,å¹´é¾„,åœ°åŒº,Telegramè´¦å·,é¢‘é“é“¾æŽ¥,æœåŠ¡ç±»åž‹,ä¿®è½¦è´¹,è‡ªæˆ‘ä»‹ç»", message.message_id);
    }
    
    const fields = caption.split(',').map(field => field.trim());
    
    if (fields.length < 8) {
      return sendMessage(chatId, `âŒ ä¿¡æ¯æ ¼å¼é”™è¯¯ï¼Œè¯·æŒ‰ä»¥ä¸‹æ ¼å¼å‘é€ï¼š\n\nèŠ±å,å¹´é¾„,åœ°åŒº,Telegramè´¦å·,é¢‘é“é“¾æŽ¥,æœåŠ¡ç±»åž‹,ä¿®è½¦è´¹,è‡ªæˆ‘ä»‹ç»\n\nå½“å‰å­—æ®µæ•°: ${fields.length}/8\n\nç¤ºä¾‹ï¼š\nç”œç”œ,18,æ˜Œå¹³å¤©é€šè‹‘,@lisifu,https://t.me/lisifu_channel,æ¯’é¾™ 69 æ·±å–‰ç­‰,600p 1200pp,æ¸©æŸ”ä½“è´´ ä¸å‚¬äºº ä¸æœºè½¦`, message.message_id);
    }
    
    const teacherData = {
      nickname: fields[0],
      age: parseInt(fields[1]) || 0,
      region: fields[2],
      telegram_account: fields[3],
      channel: fields[4],
      service_type: fields[5],
      price: fields[6], 
      intro: fields[7],
      photo_url: photoUrl,
      status: 'pending'
    };
    
    await supabaseInsert('teachers', teacherData);
    await sendTeacherToChannels(teacherData);
    
    return sendMessage(chatId, "âœ… è€å¸ˆä¿¡æ¯å·²æˆåŠŸä¸Šä¼ å¹¶åˆ†äº«ï¼", message.message_id);
  } catch (error) {
    console.error("ç…§ç‰‡å¤„ç†é”™è¯¯:", error);
    return sendMessage(chatId, `âŒ ä¸Šä¼ å¤±è´¥: ${error.message}`, message.message_id);
  }
}

// å‘é€è€å¸ˆèµ„æ–™åˆ°é¢‘é“
async function sendTeacherToChannels(teacher) {
  try {
    const caption = `ðŸŒŸ æ–°è€å¸ˆæŽ¨è ðŸŒŸ\n\n` +
                   `èŠ±å: ${teacher.nickname}\n` +
                   `å¹´é¾„: ${teacher.age}\n` +
                   `åœ°åŒº: ${teacher.region}\n` +
                   `Telegramè´¦å·: ${teacher.telegram_account}\n` +
                   `é¢‘é“: ${teacher.channel}\n` +
                   `æœåŠ¡ç±»åž‹: ${teacher.service_type}\n` +
                   `è´¹ç”¨: ${teacher.price}\n` +
                   `è‡ªæˆ‘ä»‹ç»: ${teacher.intro}`;

    for (const channelId of CHANNEL_IDS) {
      await sendPhotoToChannel(channelId, teacher.photo_url, caption);
    }
    
    for (const groupId of GROUP_IDS) {
      await sendPhotoToChannel(groupId, teacher.photo_url, caption);
    }
  } catch (error) {
    console.error("å‘é€è€å¸ˆèµ„æ–™åˆ°é¢‘é“å¤±è´¥:", error);
  }
}
